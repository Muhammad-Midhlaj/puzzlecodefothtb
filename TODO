- Need major work on usability / instructions / walkthroughs.
-- Idea for button semantics:
--- Reset, simply resets the state to initial state
---- You can only modify the source code when the game is paused and in the
     inital state. When the source is not modifiable gray it out or something.
     Whenever cursor moves to a different line, recompile the program.
--- Modify play / pause button, to play / pause /resume button
---- "play" is only available when the game is paused and in the initial
     configuration. pressing play compiles the program and begins the
     simulation (assuming there are no errors).
---- once play begins, it turns into the pause button. Pressing pause will
     pause the game and change the button to a "resume" button.
---- resume unpauses the game. (Or should the button be labelled unpause?)
-- Perhaps present a popup alert the first time you get a compile error
-- Add a "step" button
-- Highlight instructions as they are being executed.
-- Allow user to click on lines to insert break points, which display the
   "pause" button next to the line.
- Implement instructions
- Unit tests
- Puzzle system. Each puzzle contains
-- board map (e.g. coins, blocks)
-- constraints (e.g. available instructions, max program size, max cycles
    before timeout)
-- win conditions (e.g. collect N coins, stop on an exit square, )
-- description: describe the puzzle to the user
-- tips (e.g., explain the "move" instruction, how to compile program, etc.)
- Idea: Campaign format
-- Campaign is composed of a series of "worlds.""
-- Each world contains a series of puzzles. Beating certain puzzles
   opens up access to other worlds. E.g. there might be 10 puzzles in the
   "move / turn" world, but you only need to beat the 3rd to get access to the
   next world. The other 7 are optional.
- Use consistent object-creation idoms
- Multi-cycle instructions
